/**
 * nativeHostRegistrar.ts
 *
 * Called once on app startup. Writes (or refreshes) the native messaging host
 * manifest and Windows registry key so the browser extension can always find
 * the correct paths — both during development and after a real installation.
 *
 * In dev  : native-host/ lives next to the source tree.
 * In prod : electron-builder copies it to resources/native-host/ inside the
 *           install dir. We detect which case we're in via app.isPackaged.
 */

import { app }        from 'electron';
import path           from 'node:path';
import fs             from 'node:fs';
import { execSync }   from 'node:child_process';

const HOST_NAME   = 'com.securepass.bridge';
const CHROME_KEY  = `HKCU\\Software\\Google\\Chrome\\NativeMessagingHosts\\${HOST_NAME}`;
const FIREFOX_KEY = `HKCU\\Software\\Mozilla\\NativeMessagingHosts\\${HOST_NAME}`;

// ─── Locate the native-host directory ────────────────────────────────────────

function getNativeHostDir(): string {
  if (app.isPackaged) {
    // electron-builder places extraResources at <install>/resources/
    return path.join(process.resourcesPath, 'native-host');
  }
  // Dev: two levels up from dist-electron/ (or src/electron/) → project root → native-host/
  return path.resolve(app.getAppPath(), 'native-host');
}

// ─── Find node.exe ───────────────────────────────────────────────────────────

function findNodeExe(): string {
  // In packaged mode we have no guarantee the user has Node — but the host
  // script must run somehow. We try these strategies in order:
  //   1. The path stored from a previous registration (env var set by this fn)
  //   2. `where.exe node` using the full user PATH from the registry
  //   3. Common nvm / nvm4w / fnm install locations

  const cached = process.env.SECUREPASS_NODE_EXE;
  if (cached && fs.existsSync(cached)) return cached;

  // Try `where.exe node` with the user's real PATH (not Chrome's stripped one)
  try {
    const userPath = execSync(
      'powershell -NoProfile -Command "[System.Environment]::GetEnvironmentVariable(\'PATH\',\'User\')"',
      { encoding: 'utf8', timeout: 5000 }
    ).trim();

    const result = execSync('where.exe node', {
      encoding: 'utf8',
      timeout:  5000,
      env: { ...process.env, PATH: `${userPath};${process.env.PATH ?? ''}` },
    }).trim().split('\n')[0].trim();

    if (result && fs.existsSync(result)) return result;
  } catch { /* fall through */ }

  // Common locations
  const candidates = [
    process.env.SECUREPASS_NODE_EXE,
    'C:\\nvm4w\\nodejs\\node.exe',
    'C:\\Program Files\\nodejs\\node.exe',
    path.join(process.env.APPDATA ?? '', 'nvm', 'nodejs', 'node.exe'),
    path.join(process.env.LOCALAPPDATA ?? '', 'fnm_multishells', 'node.exe'),
  ].filter(Boolean) as string[];

  for (const c of candidates) {
    if (fs.existsSync(c)) return c;
  }

  // Last resort – hope `node` is visible in whatever PATH the bat inherits
  return 'node';
}

// ─── Write the bat launcher with the real node path ──────────────────────────

function writeBatFile(hostDir: string, nodeExe: string): string {
  const batPath = path.join(hostDir, 'run-host.bat');
  const content = [
    '@echo off',
    ':: Auto-generated by SecurePass on startup — do not edit by hand.',
    `"${nodeExe}" "%~dp0host.js" 2>> "%~dp0host-error.log"`,
  ].join('\r\n') + '\r\n';

  fs.writeFileSync(batPath, content, 'utf8');
  return batPath;
}

// ─── Write the native messaging manifest JSON ─────────────────────────────────

function writeManifestJson(hostDir: string, batPath: string, filename: string, extra: object): string {
  const manifestPath = path.join(hostDir, filename);
  const manifest = {
    name:        HOST_NAME,
    description: 'SecurePass NFC Password Manager bridge',
    path:        batPath.replace(/\//g, '\\'),
    type:        'stdio',
    ...extra,
  };
  fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2), 'utf8');
  return manifestPath;
}

// ─── Write registry keys ──────────────────────────────────────────────────────

function setRegistryKey(key: string, jsonPath: string) {
  const escaped = jsonPath.replace(/\\/g, '\\\\');
  execSync(`reg add "${key}" /ve /t REG_SZ /d "${escaped}" /f`, {
    windowsHide: true,
    timeout:     5000,
  });
}

// ─── Public entry-point ───────────────────────────────────────────────────────

export function registerNativeHost(log: (msg: string) => void = console.log): void {
  try {
    const hostDir = getNativeHostDir();

    if (!fs.existsSync(hostDir)) {
      log(`[NativeHostRegistrar] native-host dir not found at ${hostDir} — skipping`);
      return;
    }

    const nodeExe    = findNodeExe();
    const batPath    = writeBatFile(hostDir, nodeExe);

    const chromeJson  = writeManifestJson(hostDir, batPath, 'com.securepass.bridge.json', {
      allowed_origins: [
        // Keep whatever is already in the existing file (updated by user / setup flow)
        ...readExistingOrigins(path.join(hostDir, 'com.securepass.bridge.json')),
      ],
    });

    const firefoxJson = writeManifestJson(hostDir, batPath, 'com.securepass.bridge.firefox.json', {
      allowed_extensions: ['securepass@localhost'],
    });

    setRegistryKey(CHROME_KEY,  chromeJson);
    setRegistryKey(FIREFOX_KEY, firefoxJson);

    log(`[NativeHostRegistrar] registered OK  node=${nodeExe}`);
  } catch (err) {
    // Non-fatal — app still works; user just can't use the browser extension
    log(`[NativeHostRegistrar] registration failed: ${(err as Error).message}`);
  }
}

// ─── Preserve existing Chrome extension IDs ──────────────────────────────────

function readExistingOrigins(jsonPath: string): string[] {
  try {
    const existing = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
    return existing.allowed_origins ?? [];
  } catch {
    return [];
  }
}
